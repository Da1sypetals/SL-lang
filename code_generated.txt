
pub(crate) fn eval_lt(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
    let ord = self._order(left, right)?;
    Ok(self.heap.alloc(ObjectInner::Bool(ord.lt())))
}


pub(crate) fn eval_gt(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
    let ord = self._order(left, right)?;
    Ok(self.heap.alloc(ObjectInner::Bool(ord.gt())))
}


pub(crate) fn eval_leq(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
    let ord = self._order(left, right)?;
    Ok(self.heap.alloc(ObjectInner::Bool(ord.leq())))
}


pub(crate) fn eval_geq(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
    let ord = self._order(left, right)?;
    Ok(self.heap.alloc(ObjectInner::Bool(ord.geq())))
}

pub(crate) fn eval_add(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
        let lobj = self.eval(left)?;
        let robj = self.eval(right)?;

        let lval = self.heap.get_value(lobj);
        let rval = self.heap.get_value(robj);

        match (lval, rval) {
            (Value::Int(i1), Value::Int(i2)) => {
                //
                Ok(self.heap.alloc(ObjectInner::Int(i1 + i2)))
            }
            (Value::Float(f1), Value::Float(f2)) => {
                Ok(self.heap.alloc(ObjectInner::Float(f1 + f2)))
            }
            (l, r) => Err(TwiError::IncompatibleBinopType {
                left: l.to_string(),
                right: r.to_string(),
            }),
        }
    }


pub(crate) fn eval_minus(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
        let lobj = self.eval(left)?;
        let robj = self.eval(right)?;

        let lval = self.heap.get_value(lobj);
        let rval = self.heap.get_value(robj);

        match (lval, rval) {
            (Value::Int(i1), Value::Int(i2)) => {
                //
                Ok(self.heap.alloc(ObjectInner::Int(i1 - i2)))
            }
            (Value::Float(f1), Value::Float(f2)) => {
                Ok(self.heap.alloc(ObjectInner::Float(f1 - f2)))
            }
            (l, r) => Err(TwiError::IncompatibleBinopType {
                left: l.to_string(),
                right: r.to_string(),
            }),
        }
    }


pub(crate) fn eval_mul(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
        let lobj = self.eval(left)?;
        let robj = self.eval(right)?;

        let lval = self.heap.get_value(lobj);
        let rval = self.heap.get_value(robj);

        match (lval, rval) {
            (Value::Int(i1), Value::Int(i2)) => {
                //
                Ok(self.heap.alloc(ObjectInner::Int(i1 * i2)))
            }
            (Value::Float(f1), Value::Float(f2)) => {
                Ok(self.heap.alloc(ObjectInner::Float(f1 * f2)))
            }
            (l, r) => Err(TwiError::IncompatibleBinopType {
                left: l.to_string(),
                right: r.to_string(),
            }),
        }
    }


pub(crate) fn eval_div(&mut self, left: ExprNode, right: ExprNode) -> TwiResult<Object> {
        let lobj = self.eval(left)?;
        let robj = self.eval(right)?;

        let lval = self.heap.get_value(lobj);
        let rval = self.heap.get_value(robj);

        match (lval, rval) {
            (Value::Int(i1), Value::Int(i2)) => {
                //
                Ok(self.heap.alloc(ObjectInner::Int(i1 / i2)))
            }
            (Value::Float(f1), Value::Float(f2)) => {
                Ok(self.heap.alloc(ObjectInner::Float(f1 / f2)))
            }
            (l, r) => Err(TwiError::IncompatibleBinopType {
                left: l.to_string(),
                right: r.to_string(),
            }),
        }
    }
